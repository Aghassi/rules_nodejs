package gazelle

import (
	"log"
	"os/exec"
	"path"
	"strings"

	"github.com/bazelbuild/bazel-gazelle/config"
	"github.com/bazelbuild/bazel-gazelle/language"
	"github.com/bazelbuild/bazel-gazelle/rule"
)

type tslang struct{}

// NewLanguage returns an instance of the Gazelle plugin for rules_nodejs.
func NewLanguage() language.Language {
	return &tslang{}
}

// Kinds returns a map of maps rule names (kinds) and information on how to
// match and merge attributes that may be found in rules of those kinds. All
// kinds of rules generated for this language may be found here.
func (s *tslang) Kinds() map[string]rule.KindInfo {
	return map[string]rule.KindInfo{
		"ts_library": {
			MatchAny: false,
			NonEmptyAttrs: map[string]bool{
				"srcs": true,
			},
			MergeableAttrs: map[string]bool{
				"srcs": true,
			},
			ResolveAttrs: map[string]bool{"deps": true},
		},
	}
}

// Loads returns .bzl files and symbols they define. Every rule generated by
// GenerateRules, now or in the past, should be loadable from one of these
// files.
func (s *tslang) Loads() []rule.LoadInfo {
	return []rule.LoadInfo{
		{
			Name:    "@npm//@bazel/typscript:index.bzl",
			Symbols: []string{"ts_library"},
		},
	}
}

// GenerateRules extracts build metadata from source files in a directory.
// GenerateRules is called in each directory where an update is requested
// in depth-first post-order.
//
// args contains the arguments for GenerateRules. This is passed as a
// struct to avoid breaking implementations in the future when new
// fields are added.
//
// empty is a list of empty rules that may be deleted after merge.
//
// gen is a list of generated rules that may be updated or added.
//
// Any non-fatal errors this function encounters should be logged using
// log.Print.
func (s *tslang) GenerateRules(args language.GenerateArgs) language.GenerateResult {
	rules := []*rule.Rule{}
	imports := []interface{}{}
	empty := []*rule.Rule{}

	// NOTE(mmackay): how do we get the config for load sites into Loads()?
	// config := GetTsGenConfig(args.Config)

	base := path.Base(args.Rel)
	if base == "." {
		base = "root"
	}

	tsSrcFiles := s.findTsSrcFiles(args.RegularFiles)

	if len(tsSrcFiles) > 0 {
		tsLibraryRule := rule.NewRule("ts_library", base)
		tsLibraryRule.SetAttr("srcs", tsSrcFiles)

		tsLibraryImports := []string{}
		for _, file := range tsSrcFiles {
			deps := execTsQuery(path.Join(args.Dir, file))
			if len(deps) > 0 {
				tsLibraryImports = append(tsLibraryImports, deps...)
			}
		}

		imports = append(imports, tsLibraryImports)
		rules = append(rules, tsLibraryRule)
	}

	return language.GenerateResult{
		Gen:     rules,
		Empty:   empty,
		Imports: imports,
	}
}

// Fix repairs deprecated usage of language-specific rules in f. This is
// called before the file is indexed. Unless c.ShouldFix is true, fixes
// that delete or rename rules should not be performed.
func (s *tslang) Fix(c *config.Config, f *rule.File) {
}

func (s *tslang) findTsSrcFiles(files []string) (ret []string) {
	for _, s := range files {
		if strings.HasSuffix(s, ".ts") && !strings.HasSuffix(s, ".spec.ts") {
			ret = append(ret, s)
		}
	}
	return
}

func execTsQuery(tsFilePath string) []string {
	out, err := exec.Command("node", "ev/tooling/bzlgen/gazelle/tsquery.js", tsFilePath).Output()
	if err != nil {
		log.Fatal(err)
	}

	if len(out) == 0 {
		return []string{}
	}

	return strings.Split(string(out[:]), ",")
}
